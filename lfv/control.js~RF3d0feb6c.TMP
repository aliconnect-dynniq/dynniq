module.exports = exports = aim = require('./root/js/lib.js');
const package = require(process.cwd() + "/package.json");
console.log(package.name, package.version);
//__dirname
//const lib = require ('./root/js/lib.js');
const express = require('express');
const fs = require('fs');
const WebSocket = require('ws');
//const events = require('events');
const crypto = require('crypto');
const atob = require('atob');
const btoa = require('btoa');
var url = require('url');

const minimist = function (args, opts) {
	if (!opts) opts = {};
	var flags = { bools: {}, strings: {}, unknownFn: null };
	if (typeof opts['unknown'] === 'function') {
		flags.unknownFn = opts['unknown'];
	}
	if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
		flags.allBools = true;
	} else {
		[].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
			flags.bools[key] = true;
		});
	}

	var aliases = {};
	Object.keys(opts.alias || {}).forEach(function (key) {
		aliases[key] = [].concat(opts.alias[key]);
		aliases[key].forEach(function (x) {
			aliases[x] = [key].concat(aliases[key].filter(function (y) {
				return x !== y;
			}));
		});
	});
	[].concat(opts.string).filter(Boolean).forEach(function (key) {
		flags.strings[key] = true;
		if (aliases[key]) {
			flags.strings[aliases[key]] = true;
		}
	});
	var defaults = opts['default'] || {};
	var argv = { _: [] };
	Object.keys(flags.bools).forEach(function (key) {
		setArg(key, defaults[key] === undefined ? false : defaults[key]);
	});
	var notFlags = [];
	if (args.indexOf('--') !== -1) {
		notFlags = args.slice(args.indexOf('--') + 1);
		args = args.slice(0, args.indexOf('--'));
	}
	function argDefined(key, arg) {
		return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
	}
	function setArg(key, val, arg) {
		if (arg && flags.unknownFn && !argDefined(key, arg)) {
			if (flags.unknownFn(arg) === false) return;
		}

		var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
		;
		setKey(argv, key.split('.'), value);

		(aliases[key] || []).forEach(function (x) {
			setKey(argv, x.split('.'), value);
		});
	}
	function setKey(obj, keys, value) {
		var o = obj;
		keys.slice(0, -1).forEach(function (key) {
			if (o[key] === undefined) o[key] = {};
			o = o[key];
		});
		var key = keys[keys.length - 1];
		if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
			o[key] = value;
		}
		else if (Array.isArray(o[key])) {			o[key].push(value);		}
		else {
			o[key] = [o[key], value];
		}
	}
	function aliasIsBoolean(key) {
		return aliases[key].some(function (x) {
			return flags.bools[x];
		});
	}
	for (var i = 0; i < args.length; i++) {
		var arg = args[i];
		if (/^--.+=/.test(arg)) {
			// Using [\s\S] instead of . because js doesn't support the
			// 'dotall' regex modifier. See:
			// http://stackoverflow.com/a/1068308/13216
			var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
			var key = m[1];
			var value = m[2];
			if (flags.bools[key]) {
				value = value !== 'false';
			}
			setArg(key, value, arg);
		}
		else if (/^--no-.+/.test(arg)) {
			var key = arg.match(/^--no-(.+)/)[1];
			setArg(key, false, arg);
		}
		else if (/^--.+/.test(arg)) {
			var key = arg.match(/^--(.+)/)[1];
			var next = args[i + 1];
			if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
				setArg(key, next, arg);
				i++;
			}
			else if (/^(true|false)$/.test(next)) {
				setArg(key, next === 'true', arg);
				i++;
			}
			else {
				setArg(key, flags.strings[key] ? '' : true, arg);
			}
		}
		else if (/^-[^-]+/.test(arg)) {
			var letters = arg.slice(1, -1).split('');

			var broken = false;
			for (var j = 0; j < letters.length; j++) {
				var next = arg.slice(j + 2);

				if (next === '-') {
					setArg(letters[j], next, arg)
					continue;
				}

				if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
					setArg(letters[j], next.split('=')[1], arg);
					broken = true;
					break;
				}

				if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
					setArg(letters[j], next, arg);
					broken = true;
					break;
				}

				if (letters[j + 1] && letters[j + 1].match(/\W/)) {
					setArg(letters[j], arg.slice(j + 2), arg);
					broken = true;
					break;
				}
				else {
					setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
				}
			}

			var key = arg.slice(-1)[0];
			if (!broken && key !== '-') {
				if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
					setArg(key, args[i + 1], arg);
					i++;
				}
				else if (args[i + 1] && /true|false/.test(args[i + 1])) {
					setArg(key, args[i + 1] === 'true', arg);
					i++;
				}
				else {
					setArg(key, flags.strings[key] ? '' : true, arg);
				}
			}
		}
		else {
			if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
				argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
			}
			if (opts.stopEarly) {
				argv._.push.apply(argv._, args.slice(i + 1));
				break;
			}
		}
	}
	Object.keys(defaults).forEach(function (key) {
		if (!hasKey(argv, key.split('.'))) {
			setKey(argv, key.split('.'), defaults[key]);

			(aliases[key] || []).forEach(function (x) {
				setKey(argv, x.split('.'), defaults[key]);
			});
		}
	});
	if (opts['--']) {
		argv['--'] = new Array();
		notFlags.forEach(function (key) {
			argv['--'].push(key);
		});
	}
	else {
		notFlags.forEach(function (key) {
			argv._.push(key);
		});
	}

	return argv;
};
const hasKey = function (obj, keys) {
	var o = obj;
	keys.slice(0, -1).forEach(function (key) {
		o = (o[key] || {});
	});
	var key = keys[keys.length - 1];
	return key in o;
};
const isNumber = function (x) {
	if (typeof x === 'number') return true;
	if (/^0x[0-9a-f]+$/i.test(x)) return true;
	return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
};
const argv = minimist(process.argv.slice(2));

//module.exports = exports = aim = require ('./root/js/lib.js');
//Object.assign ( aim, new events() );
// a = new aim.server;
// a.a();
// aim.testmessage = 'TEST MAX';
//console.log(a,aim);
// aim.test1 = function () {
// 	console.log('aimtest',this);
// }
// aim.on('online',function(){
// 	console.log('ik ben online');
// });
// aim.on('online',function(){
// 	console.log('ik ben ook online');
// });

//aim.emit('online');

//module.exports = exports = aim = Object.assign ( new events(), lib );


//exports.test = 'TEST MODULE';
//aim.test1();
//lib.testmessage = 'TESTer MAX';

//console.log(aim);

//lib.test();

aim.config = Object.assign(require(require('path').resolve(argv.config ? (argv.config[0] === "/" ? argv.config : process.cwd() + "/" + argv.config) : "./aim.config.json").replace(/\\/g, "/")), argv);
aim.secret = aim.config.secret ? require(aim.config.secret[0] == '/' ? aim.config.secret : process.cwd() + "/" + aim.config.secret) : {};
aim.api = aim.config.api ? require(aim.config.api[0] == '/' ? aim.config.api : process.cwd() + "/" + aim.config.api) : {};
aim.data = aim.config.data ? require(aim.config.data[0] == '/' ? aim.config.data : process.cwd() + "/" + aim.config.data) : {};





http = {
		request : function(req,res) {
			console.log("NODE HTTP REQUEST");

		},
		processRequest : processRequest = function (req, res) {
			res.setHeader('Access-Control-Allow-Origin', '*');
			res.setHeader('Access-Control-Request-Method', '*');
			res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');
			res.setHeader('Access-Control-Allow-Headers', '*');

			var q = url.parse(req.url, true), pathname = q.pathname, path = pathname.substr(1).split("/"), root = path.shift(), rootpath = process.cwd() + "/root";

			if (root=='api') {
				//console.log("REQ",req.body);
				req.body = '';
			    req.on('data', chunk => {
			        req.body += chunk.toString(); // convert Buffer to string
			    });
				req.on('end', () => {
					var result = apiRequest(req);
					//console.log("REQ RESULT",result);
					if (result) {
						//res.statusCode = result.status;
						//res.status(201).send({message : 'registrations compelete'});
						if (result.status >= 400) res.statusCode = result.status;
						else if (result.body) {
							res.writeHead(result.status, { 'Content-Type': 'application/json' });
							res.write(JSON.stringify(result.body));
						}
						else res.statusCode = 202; // no content
						return res.end();
					};
					//console.log(body);
					return res.end('ok');

			    });
				return;
			}

			var file_ext = ['.html', '/index.html', '/index.htm', '/README.md',''], rootpaths = [ rootpath + pathname , rootpath + "/" + root, "./node_modules/aim-control" ], files = [];
			rootpaths.forEach(function(path){file_ext.forEach(function(ext){files.push(path+ext);})});
			for (var i=0, filename, fileExists; filename = files[i]; i++) if (fileExists = fs.existsSync(filename = files[i])) break;
			if (!fileExists) {
				res.writeHead(404, { 'Content-Type': 'text/html' });
				return res.end("404 Not Found: " + req.url);
			}

			var ext = filename.split('.').pop()
			//console.log(filename);
			fs.readFile(filename, function (err, data) {
				if (err) {
					res.writeHead(404, { 'Content-Type': 'text/html' });
					return res.end("404 Not Found " + req.url);
				}
				if (ext == 'md') {
					data = '<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" href="/css/theme/aliconnect.css" /><link rel="stylesheet" href="/css/document.css" /><div class="doc-content">' + converter.makeHtml(String(data)) + '</div>';
					ext = 'html';
				}
				res.writeHead(200, { 'Content-Type': 'text/' + ext });
				res.write(data);
				return res.end();
			});
			//
			//
			// var filename = process.cwd() + "/root" + q.pathname;
			// console.log(filename);
			// fs.readFile(filename, function (err, data) {
			// 	if (err) {
			// 		res.writeHead(404, { 'Content-Type': 'text/html' });
			// 		return res.end("404 Not Found aaa");
			// 	}
			// 	res.writeHead(200, { 'Content-Type': 'text/html' });
			// 	res.write(data);
			// 	return res.end();
			// });
		},
		server : !aim.config.http ? null : require(aim.config.http.cert ? "https" : "http").createServer(aim.config.http.cert ? {
			key: fs.readFileSync(aim.config.http.key),
			cert: fs.readFileSync(aim.config.http.cert),
			ca : aim.config.http.ca ? fs.readFileSync(aim.config.http.ca) : null,
		} : null, this.processRequest).listen(aim.config.http.port)
	};
ws = {
		onmessage : function (message) {
			try { message = JSON.parse(message); } catch (err) { console.log(message); return; }
			var wsc = this, result = null;
			if (result = aim.apiRequest(message)) wsc.send(JSON.stringify(Object.assign(result,{id:message.id})));

			console.log('WebSocketClient message',message.method, message.url, result);

			return;
			/** Handle connect from control device */
			if (message.ip_addresses) {


				wsc.access = {
					aud: 3549983,
					id: wsc.sid,
				};




				var mac = message.ip_addresses[wsc.remoteAddress];
				wsc.mac_address = mac;
				if (wsc.access) wsc.access.mac = mac;

				console.log('WebSocketServer IP received, reply mac address',wsc.remoteAddress,mac);


				//console.log('request login', wsc.remoteAddress, wsc.mac_address);
				if (aim.config.mac && aim.config.mac[wsc.mac_address]) {
					aimdb.log(wsc.remoteAddress,wsc.mac_address,'aim.config found and uploaded');
					//console.log('aim.config', aim.config.mac[wsc.mac_address]);

					wsc.send(JSON.stringify({ access:wsc.access, config: aim.config.mac[wsc.mac_address] }));

					wsc.client = aim.config.mac[wsc.mac_address].client;
				}
				else {
					aimdb.log(wsc.remoteAddress,wsc.mac_address,'NO aim.config found');
					wsc.send(JSON.stringify({ access:wsc.access }));
				}

				return;
				//wsc.send(JSON.stringify({items:rows.map(function (item) { return Object.assign({}, item, { children: null, device: null }); })}));

				//wsc.mac_id = parseInt(mac.replace(/:/g, ''), 16);
				//console.log('mac', mac, parseInt(mac.replace(/:/g, ''), 16));
				//(function sendpos() {
				//	if (this.readyState != this.OPEN) return;
				//	//console.log('send test');
				//	var message = "gkjhgjhgjhgkjh";
				//	var aim.secret = "5ebabb5e-0a5b-4c87-a970-1919a4680fb1";
				//	this.send(['', message, crypto.createHmac('sha256', aim.secret).update(message).digest('base64')].join('.'));

				//	//this.send(JSON.stringify({ action: 'test' }));

				//	setTimeout(arguments.callee.bind(this), 1000);
				//}.bind(this))();
			}
			if (message.access_token) {
				//wsc.access_token = message.access_token;
				var arr = message.access_token.split('.'),
					base64_header = arr.shift(),
					base64_payload = arr.shift(),
					payload = wsc.access = JSON.parse(atob(base64_payload)),
					base64_signature = arr.shift();
				//console.log(wsc.access);
				if (!wsc.access.client_id) return;
				new sql.Request().query("SELECT S.id,S.client_secret FROM auth.aim.secret S WHERE S.id = "+wsc.access.client_id, function (err, res) {
					var message=this.message;

					if (err) wsc.send(JSON.stringify(err));
					//if (err) console.log(err);
					var row = res.recordsets[0][0], client_secret = res.recordsets[0][0].client_secret;
					//console.log('secret_id', wsc.secret_id);
					var checksignature = crypto.createHmac('sha256', client_secret).update([base64_header, base64_payload].join('.')).digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');

					/** debug */
					//if (base64_signature != checksignature) wsc.send(JSON.stringify({err:"Unauthorized"}));



					//wsc.signatureOk = base64_signature == checksignature;
					wsc.access.ip = wsc.remoteAddress;
					//if ()
					//Object.assign(wsc.access,{remoteAddress: wsc.remoteAddress, mac_address:wsc.mac_address});
					//console.log('login', wsc.access);
					wsc.access.sid = req.headers['sec-websocket-key']
					var message = { connection_state: 'connect', from: wsc.access };
					wsc.send(JSON.stringify(message));
					//console.log(wsc.access);
					//console.log('login', wsc.access.aud,wsc.access.sub,wsc.access.client_id,wsc.access.ip,wsc.access.sid);
					send(message, wsc);

					//console.log(base64_header);
					//console.log(base64_payload);
					//console.log(base64_signature);
					//console.log(checksignature);
					//wsc.auth = payload;
					//console.log();
					//wsc.send({ access_token: wsc.access_token, mac_address: wsc.mac_address });
					//message.login = message.login || payload;
				}.bind({message:message}));
				//wsc.send(JSON.stringify({ err: 'No id' }));




				//console.log(message);
				//console.log('payload.id', atob(base64_payload));
				//console.log('payload.id', payload.id);

				//aimdb.log(wsc.remoteAddress,'access',payload.aud,payload.azp,payload.sub,payload.client_id);
				/** @todo Token ontvangen, moet deze gaan verifieren met de database, check op secret_id gebaseerd op JWT token id? */

				//send(message, wsc);



				// if (payload.id) new sql.Request().query("SELECT lower(T.aim.secret)secret_id FROM auth.token T INNER JOIN om.items I ON I.id=T.id AND I.uid='" + payload.id + "'", function (err, res) {
				// 	wsc.send(JSON.stringify(err));
				// 	//if (err) console.log(err);
				// 	if (res && res.recordsets[0] && res.recordsets[0][0]) {
				// 		wsc.secret_id = res.recordsets[0][0].secret_id;
				// 		//console.log('secret_id', wsc.secret_id);
				// 		var checksignature = crypto.createHmac('sha256', wsc.secret_id).update([base64_header, base64_payload].join('.')).digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
				// 		wsc.signatureOk = base64_signature == checksignature;
				// 		console.log('login', wsc.remoteAddress, wsc.mac_address);
				// 		//console.log(base64_header);
				// 		//console.log(base64_payload);
				// 		//console.log(base64_signature);
				// 		//console.log(checksignature);
				// 		//wsc.auth = payload;
				// 		//console.log();
				// 		//wsc.send({ access_token: wsc.access_token, mac_address: wsc.mac_address });
				// 		//message.login = message.login || payload;
				// 	}
				// });
				// wsc.send(JSON.stringify({ err: 'No id' }));
				return;
			}
			if (!wsc.access) return;
			// if (message.url=='items') {
			// 	console.log(items);
			// 	wsc.send(JSON.stringify({items:{max:'s'}}));
			// 	return;
			// }
			message.from = wsc ? wsc.access : { aud: config.aud };
			console.log('WebSocketServer send to aud', message.from, wsc.access.aud, message.method, message.url);
			wss.clients.forEach(function (wsa) {
				if (wsa.readyState !== wsa.OPEN || !wsa.access || wsc == wsa) return;
				//if (wsa.readyState !== wsa.OPEN || !wsa.access ) return;
				//console.log('aa',wsc.access);
				//if (!wsc) return wsa.send(JSON.stringify(message));
				//if (!message.from.app) console.log(message.from);
				//if (message.state=='test') console.log(message.from.app, message.state, message.to);
				//console.log('send' , wsc.access.aud , wsa.access.aud);
				if (message.to) {
					for (var name in message.to) if (!wsa.access[name] || message.to[name] != (wsa.access[name].id || wsa.access[name])) return
					return wsa.send(JSON.stringify(message));
				}
				for (var i=0, names=["sub","aud","client_id"], name; name = names[i];i++) {
					if (message.from[name] && wsa.access && wsa.access[name] && message.from[name] == wsa.access[name]) {
						console.log('send to',wsa.access.sid);
						wsa.send(JSON.stringify(message));
						return;
					}
				}
			});


			if (message.access) {
				console.log('WebSocketClient access received',this.access = message.access);
				if (!aim.items.length) {
					console.log('WebSocketClient Request for items');
					aim.ws.send(JSON.stringify({ url: "items", method: "GET" }));
				}
				return;
			}
			//console.log(api.paths[message.url]);
			if (message.url) return apiRequest.call(message);


			if (message.config) saveConfig(config = message.config);
			if (message.access_token) saveConfig(config.access_token = message.access_token);

			// if (message.operations) for (var methodname in message.operations) {
			// 	var method = module.parent[methodname] || module.exports[methodname];
			// 	if (config.require) for (var modulename in config.require) {
			// 		if (method = method || module[modulename][methodname]) break;
			// 	}
			// 	if (!method) console.log('Operation not found',name);
			// 	method.apply(module,message.operations[methodname]);
			// }

			//this.send(JSON.stringify(response));

			//aim.emit('message',(message));
		},
		onopen: function () {
			this.readyState = 1;
			var networkInterfaces = require('os').networkInterfaces(), ip_addresses = {};
			//console.log(networkInterfaces);
			for (var name in networkInterfaces) networkInterfaces[name].forEach(function (conn) {
				//if (conn.address.split('.').length == 4 && Number(conn.mac.replace(/:/g, '')) !== 0)
				if (conn.address) ip_addresses[conn.address] = conn.mac;
			});
			console.log('WebSocketClient Open, sending IP addresses', ip_addresses);
			//this.send(JSON.stringify({ ip_addresses: ip_addresses, login: { device_id: aim.config.device_id } }));
			aim.ws.send(JSON.stringify({ ip_addresses: ip_addresses, client_id: aim.config.client_id }));
			//this.send(JSON.stringify({ ip_addresses: ip_addresses, access_token: aim.config.access_token||'', login: aim.config.client }));
			//sendNumber();
			//aim.emit('open');
		},
		onclose:  function () {
			console.log('wsc close');
			setTimeout(aim.wsc.connect, 10000);
			clearTimeout(this.pingTimeout);
			//this.pingTimeout=setTimeout(function, 1000);
			// aim.emit('wscClose');
		},
		onerror:  function () {
			console.log('ws error');
			// aim.emit('wscClose');
		},
		connect: function () {
			console.log('WebSocketClient connecting',aim.config.ws.url);
			//this.WebSocket = new WebSocket('ws://192.168.0.201:81');
			//this.WebSocket = new WebSocket('ws://192.168.1.122:81');
			//this.WebSocket = new WebSocket(aim.config.https.protocol + '://' + aim.config.https.address + ':' + aim.config.https.port);
			aim.ws = Object.assign(new WebSocket(aim.config.ws.url),aim.ws).on('open', this.onopen).on('close', this.onclose).on('error', this.onerror).on('message', this.onmessage);
		},
		request : function(req,res) {
			console.log("NODE WS REQUEST");

		},
	}
	wss = {
		request : function(req,res) {
			console.log("aim.request",req);
			wss.clients.forEach(function (wsa) {
				var wsc = {
					access : {
						aud: aim.config.aud
					}
				}
				if (wsa.readyState !== wsa.OPEN) return;
				if (req.to) {
					for (var name in req.to) if (!wsa.access[name] || req.to[name] != (wsa.access[name].id || wsa.access[name])) return
					return wsa.send(JSON.stringify(req));
				}
				for (var i=0, names=["sub","aud","client_id"], name; name = names[i];i++) {
					if (1) {//}(message.from[name] && wsa.access && wsa.access[name] && message.from[name] == wsa.access[name]) {
						//console.log('send to',wsa.access.sid);
						wsa.send(JSON.stringify(req));
						return;
					}
				}
			});
		},
		onmessage: function (message) {
			try { message = JSON.parse(message); } catch (err) { console.log('WebSocketServer message error',message); return; }



			// if (items=message.items) return create_items();
			//
			// if (message.aim.config) saveConfig(aim.config = message.aim.config);
			// if (message.access_token) saveConfig(aim.config.access_token = message.access_token);
			// if (message.url) return executeUrl.call(this,message);
			// else if (message.requests) {
			// 	var responses=[];
			// 	message.requests.forEach(function(request){responses.push(executeUrl(request).call(this));}.bind(this));
			// 	return {responses:responses};
			// }
			//
			console.log('WebSocketServer message');

			//console.log(message.access_token);


			return;

			if (message.url=='items') return wsc.send(JSON.stringify({items:rows.map(function (item) { return Object.assign({}, item, { children: null, device: null }); })}));


			// if (message.login) {
			// 	console.log(message.login);
			// 	wsc.client = message.login;
			// 	wsc.client.socket = { id: req.headers['sec-websocket-key'] };
			// 	if (message.ip_addresses) {
			// 		var mac = message.ip_addresses[this.remoteAddress];
			// 		wsc.client.mac_address = mac;
			// 		wsc.client.mac_id = parseInt(mac.replace(/:/g, ''), 16);
			// 		//console.log('mac', mac, parseInt(mac.replace(/:/g, ''), 16));
			// 		//(function sendpos() {
			// 		//	if (this.readyState != this.OPEN) return;
			// 		//	//console.log('send test');
			// 		//	var message = "gkjhgjhgjhgkjh";
			// 		//	var aim.secret = "5ebabb5e-0a5b-4c87-a970-1919a4680fb1";
			// 		//	this.send(['', message, crypto.createHmac('sha256', aim.secret).update(message).digest('base64')].join('.'));
			//
			// 		//	//this.send(JSON.stringify({ action: 'test' }));
			//
			// 		//	setTimeout(arguments.callee.bind(this), 1000);
			// 		//}.bind(this))();
			// 	}
			// 	console.log(wsc.client);
			//
			//
			// 	message.from = wsc.client;
			// 	message.state = 'connected';
			// 	if (wsc.readyState == wsc.OPEN) {
			// 		message.value = rows.map(function (item) { return Object.assign({}, item, { children: null, device: null }); });
			//
			// 		message.access_token = jwt_encode({ testmax: 1 }, 'sfasda');
			// 		//wsc.send(JSON.stringify({testmax:1}));
			//
			//
			//
			//
			// 		wsc.send(JSON.stringify(message));
			// 		delete message.value;
			// 	}
			// 	delete message.login;
			// 	delete message.access_token;
			// }


			//if (!message.to && wsc.client.to) message.to = wsc.client.to;
			console.log('to', message.to);
			if (message.post && message.value) setValue(message.value);
			//message.from = wsc.client;
			send(message, wsc);
			//wss.clients.forEach(function (cl) {
			//	console.log(cl.client);
			//	if (cl !== wsc) cl.send(message);
			//	//console.log(cl);
			//});
		},
		onclose: function (connection) {
			aimdb.log(this.remoteAddress,'disconnect' );
			//send({ state: 'disconnected' }, this);
			console.log('disconnect');
		},
		onconnection : function (ws, req) {
			ws.on('close', this.onclose);
			ws.on('message', ws.onmessage);
			ws.remoteAddress = req.connection.remoteAddress.split(':').pop();
			ws.sid = req.headers['sec-websocket-key'];
			//console.log('connection', req.connection.remoteAddress);
			aimdb.log(wsc.remoteAddress,'connection');
			//var i = [];
			//recursive = function (o) { if (i.indexOf(o) != -1) return; i.push(o); if (typeof o == 'string' && String(o).indexOf(':')!=-1) console.log(String(o)); for (var name in o) recursive(o[name])};
			//recursive(req);
			//recursive(ws);

			console.log('connect', req.connection.remoteAddress);
			ws.send(JSON.stringify({
				client_id : aim.config.client_id,
				sid : ws.sid = module.sid = req.headers['sec-websocket-key'].replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '')
			}));
		},
		connect: function() {
			if (aim.config.http) {
				this.server = new WebSocket.Server({ server: aim.http.server }).on('connection', this.onconnection);
				console.log('WebSocketServer is up and running', aim.config.http.port);
			}
			ws.connect();
			if (aim.config.mqqt) {
				if (aim.config.http.cert) aim.config.mqqt.secure = { keyPath: aim.config.http.key, certPath: aim.config.http.cert };
				var moscaserver = new require('mosca').Server(aim.config.mqqt);
				moscaserver.on('ready', function () {
					console.log('MQTT server is up and running')
				});
				// fired when a message is published
				moscaserver.on('published', function (packet, client) {
					//console.log('Published', packet);
					//console.log('Client', client);
				});
				// fired when a client connects
				moscaserver.on('clientConnected', function (client) {
					//console.log('Client Connected:', client.id);
				});
				// fired when a client disconnects
				moscaserver.on('clientDisconnected', function (client) {
					//console.log('Client Disconnected:', client.id);
				});
				console.log('MQTT Server is up and running', aim.config.mqqt.port);
			}
			//}
		},
	}
	api = {
		request : function(req,res) {
			console.log("NODE API REQUEST");

		},
		paths : {
			"items": {
				"GET": {
					operation: function(body) {
						console.log("REQUEST FOR ITEMS RECEIVE, SENDING ALL ITEMS TO BROKER, target = sub OF request");//create_items();
						aim.ws.send(JSON.stringify({url: "items", method: "POST", body: rows.map(function (item) { return Object.assign({}, item, { children: null, device: null }); }) }));
					}
				},
				"POST": {
					operation: function(body) {
						console.log("Items received, generate data");//create_items();
						control_items(body);

						//aim.ws.send(JSON.stringify({method:"PUT",url:"items",body:[{id:1}]}));
					}
				},
				"PATCH": {
					operation: function(body) {
						if (aim.sql) {
							console.log("UPDATE DATA ON DATABASE",body);
						}
					}
				},
			},
		}
	}
	dbs = aim.secret.dbs ? {
		getSqlParams : getSqlParams = function (object) {
			var params = [];
			for (var property in object) params.push('@' + property + "='" + String(object[property]).replace(/'/g, "''") + "'");
			return params.join(',');
		},
		sql : sql = require('mssql'),
		conn : sql.connect(aim.secret.dbs, function (err) {
			console.log('aim.dbs connected 1', aim.secret.dbs.server + ":" + aim.secret.dbs.port + "/" + aim.secret.dbs.database);
			//aim.emit('dbConnect');
			//aim.sql.emit('connect',err);
			//console.log('no sql');
			//WebSocketServer_start();
			//return;
			if (err) return console.log(err);
			if (aim.config.aud) {
				console.log('loading', aim.config.aud);
				aim.dbs.request ("EXEC api.getTree " + aim.config.aud, function(res){
					//rows = res.recordsets[0];
					rows = res[0];
					//console.log("RES",rows);
					//console.log(rows);
					for (var i = 0, row; row = rows[i]; i++) items[row.id] = Object.assign(row, { children: [], values: {} });
					for (var i = 0, row; row = res[1][i]; i++) items[row.id].values[row.name] = { value: items[row.id][row.name] = isNaN(row.value) ? row.value : Number(row.value) };
					items.forEach(function (item) { if (item.masterID && items[item.masterID]) items[item.masterID].children.push(item); });
					items.forEach(function (item) {
						if (item.selected == 0) {
							(recursive = function (item) {
								item = items[item.detailID || item.id];
								item.selected = 0;
								(item.values.Value = item.values.Value || {}).value = item.Value = null;
								item.children.forEach(recursive);
							})(item);
						}
					});
					items.forEach(attributeChange);
					//items.forEach(function (item) { if (item.schema=='ControlIO') attributeChange(item); });
					aim.wss.connect();

					return;



					setState(items[aim.config.freeMemID], 'connect');
					setState(items[aim.config.freeDiskSpaceID], 'connect');
					setState(items[aim.config.timeSyncID], 'connect');

				});
			}
			else aim.wss.connect();
		}),
		request : function(req, res) {
			console.log("NODE DB REQUEST".req);
			new sql.Request().query(req,function (err, queryres){
				if (err) return console.log(err);
				//console.log(queryres.recordsets);
				if (res) res(queryres.recordsets);
			});
		},
	} : wss.connect();

i2c = {};//new events();



if (aim.data.i2c) {
	mcp23017 = require('node-mcp23017');
	for (var id in aim.data.i2c) {
		aim.data.i2c[id].address = parseInt(aim.data.i2c[id].address);
		//console.log(id,aim.data.i2c[id]);
		var rio = aim.i2c[id] = new mcp23017(aim.data.i2c[id]);
		/**
		@todo MKA alle pins zijn nu output, input functies nog verwerken ook in data
		@todo Inputs genereren een event, hoe gaan we dit verder verwerken?
		*/
		for (var i = 0; i < 16; i++) {			rio.digitalWrite(i, 1);			rio.pinMode(i, rio.OUTPUT); }
	}
	aim.digitalWrite = function(i2cId,pin,value) {
		var rio = aim.i2c[i2cId];
		rio.digitalWrite(pin, value);
	}
}

const saveConfig = function () {
	fs.writeFile('aim.config.json', JSON.stringify(aim.config, null, 2), function (err) {
		if (err) throw err;
		console.log('Config Saved!');
	});
}
if (aim.config.src) for (var i=0, cfg; cfg = aim.config.src[i];i++) {
	const req = require("https").request({hostname: 'aliconnect.nl', port: 443, method: 'GET', path: '/'+cfg.source}, function (res) {
		res.on('data', function (d) {
			console.log(String(d));
			fs.writeFile(process.cwd() + '/' + this.dest, String(d), function (err) {
						if (err) throw err;			}.bind(this));

		}.bind(this));
	}.bind(cfg));
	req.on('error', (error) => {	console.error(error)});
	//req.write(par.input);
	req.end();
}
if (aim.config.require) for (var name in aim.config.require) {
	const req = require("https").request({hostname: 'aliconnect.nl',port: 443,path: '/' + aim.config.require[name] , method: 'GET'}, function (res) {
		res.on('data', function (d){
			fs.writeFile(process.cwd() + '/' + this.name+'.js', String(d), function (err) {
				if (err) throw err;
				module[this.name] = require(process.cwd()+'/'+this.name+'.js');
			}.bind(this));
		}.bind(this));
	}.bind({name:name}));
	req.on('error', (error) => {	console.error(error)});
	req.end();
}

/** Loading crypto for JWT and access_token encription **/

/** Loading aim.ws's **/

module.token = function(nr){
	console.log("Token",module.sid);
	//return;
	var signature = crypto.createHmac('sha256', aim.config.client_secret.toUpperCase()).update(module.sid).digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, ''), cnt=1;
	for (i = 0;i<signature.length;i++) {
		cnt = Number(String(cnt + cnt * signature.charCodeAt(i)).replace(/0/g,"")) % 100000000;
		//console.log(i,signature[i],signature.charCodeAt(i),cnt);
	}
	//for (i = 0;i<signature.length;i++) cnt += i * signature.charCodeAt(i);

	//for (i = 0;i<signature.length;i++) cnt+= signature.charCodeAt(i);


	//console.log(cnt);

	if (String(cnt).substr(-5) != nr) return {status:405, body:{error:'Unauthorized'}}; // Unauthorized
	return {status:200};//, body:{cnt:String(cnt).substr(-5), aim.secret:aim.config.client_secret.toUpperCase(), signature:signature, sid:this.sid }};
}


const setState = function (item, value) {
	if (item.State != value) setAttribute(item, 'State', value);
};
const setAttribute = function (item, attributeName, value, nochange) {
	if (!item || item[attributeName] === value) return;
	//aimdb.log('setAttribute', item.id, { [attributeName]: value, extra: [item[attributeName], typeof item[attributeName], typeof value], });
	aimdb.log('setAttribute', item.id, { [attributeName]: value });
	//item.values = item.values || {};
	item.values[attributeName] = item.values[attributeName] || {};
	item[attributeName] = item.values[attributeName].value = value;
	item.modifiedDT = new Date().toISOString();
	//if ([3562893, 3562891, 3562878, 3562876, 3549983].indexOf(item.id) != -1) { console.log('setAttribute CriticalFailure', item.CriticalFailure, item.values.CriticalFailure); }
	//if ([3562891].indexOf(item.id) != -1) {
	//	console.log('setAttribute CriticalFailure', item.id, item.title, item.CriticalFailure, item.values);
	//}

	setItem({ id: item.id, values: { [attributeName]: { value: value } } });
	//attributes.emit('change', item, attributeName, value);
	//if (attributeName == 'Value' && !nochange) attributeChange.call({ inout: 'in' }, { id: item.id, [attributeName]: value, values: { [attributeName]: { value: value } } });

	if (attributeName == 'Value' && !nochange && item.children) item.children.forEach(attributeChange.bind(item));

};

aimdb = {
	querylist: [],
	exec: function () {
		var request = new sql.Request();
		request.query(this.querylist.join(';'), function (err, res) { if (err) console.log(err); });
		this.querylist = [];
	},
	post: function (sql) {
		this.querylist.push(sql);
		clearTimeout(this.querylist.to);
		this.querylist.to = setTimeout(this.exec.bind(this), 0);
	},
	log: function (level) {
		var arg = Array.prototype.slice.call(arguments);
		if (!aim.config.loglevel || Number(aim.config.loglevel) <= Number(level)) return;
		if (Number(level)) arg.shift();
		var method = arg.shift()||'';
		var id = Number(arg[0]) ? arg.shift() : null;
		var path = !id ? "" : function () {
			var item = items[id];
			for (var path = [], master = item; master; master = items[master.masterID]) {
				path.push(master.title);
				if (master.class == 'dms_Location') break;
			}
			return path.reverse().join(".");
		}();
		//aimdb.post("INSERT aimhis.om.event(method,value,id,path)VALUES('" + method + "','" + JSON.stringify(arg) + "'," + (id || 'NULL') + ",'" + path + "')");
		console.log(new Date().toISOString().replace("T", " ").replace("Z", ""), path, id, method, String(JSON.stringify(arg)).replace(/":/g, '=').replace(/"|{|}/g, ""));
	}
};

var setItems = [], rows = [], items = aim.items = [];
const setItem = function (item) {
	clearTimeout(setItems.setItemTimeout);
	if (!item) {
		//setItems.forEach(function (row) { row.values.modifiedDT = { value: new Date().toISOString() }; });
		setValue(setItems);
		//console.log('SEND', JSON.stringify(setItems));
		if (!aim.ws || aim.ws.readyState !== aim.ws.OPEN) return;
		console.log(aim.ws);
		aim.ws.send(JSON.stringify({ method:'PATCH', url:'items', body: { value: setItems } }));
		setItems = [];
		return;
	}
	//log(3, 'setItemValues', JSON.stringify(item));
	setItems.push(item);
	setItems.setItemTimeout = setTimeout(setItem, 100);
};
const setValue = function (value) {
	value.forEach(function (row) {
		if (!row.id) return;
		var item = items[row.id];
		if(!item) return;
		//console.log(item);
		if (row.values) for (var name in row.values) postAttribute(row, name, (item.values[name] = item.values[name] || {}).value = item[name] = row.values[name].value);
		for (var name in row) if (name != 'values') postAttribute(row, name, item[name] = row[name]);
	});
	//attributes.emit('change', value);
};
const postAttribute = function (item, name, attribute) {
	if (['id', 'values', 'eventType', 'ofile'].indexOf(name) != -1) return;
	if (typeof attribute != "object") attribute = { value: attribute };
	aimdb.post("EXEC api.setAttribute " + getSqlParams(Object.assign(attribute, { id: item.id, name: name })));
};

const control_items = function(items){
	aim.items = items;
	console.log('Build control items');
	items.forEach(function (item) { if (item) item.children=[]; });
	items.forEach(function (item) { if (item.masterID && items[item.masterID]) items[item.masterID].children.push(item); });
	items.forEach(function (item) {
		if (item && item.selected == 0) {
			(recursive = function (item) {
				if (!(item = items[item.detailID || item.id])) return;
				item.selected = 0;
				(item.values.Value = item.values.Value || {}).value = item.Value = null;
				item.children.forEach(recursive);
			})(item);
		}
	});

	var snmpDevices = [], modbusDevices = [], devices = [];
	devices.connect = function () {
		var device = devices.shift();
		if (device) device.connect();
	}
	items.forEach(function (item, i) {
		if (!item.selected || !item.IPAddress || !item.PollInterval) return;
		//console.log(item.id);
		if (item.Community) return snmpDevices.push(item);
		/**
			* @author Max van Kampen <max.van.kampen@alicon.nl>
			* @todo Write the documentation.
			* @version Write the documentation.
			* @example Alleen aanmaken modbus device met sepcifiek IP adres voor testen.
			*/
		//if (item.IPAddress == '192.168.2.3') modbusDevices.push(item);
		//if (item.IPAddress == '192.168.2.5') modbusDevices.push(item);
		modbusDevices.push(item);
	});
	/**
		* @author Max van Kampen <max.van.kampen@alicon.nl>
		* @test Leegmaken van lijsten voor testen.
		*/
	//snmpDevices = [];
	//modbusDevices = [];
	//console.log(modbusDevices);
	const net = require('net')
	const Modbus = require('jsmodbus');

	modbusDevices.forEach(function (item, i) {
		devices.push(device = { item: item });
		var socket = device.socket = new net.Socket();
		device.client = new Modbus.client.TCP(device.socket, i + 1);
		device.client.device = device.socket.device = device;
		Object.assign(device, { ReadAddress: item.children.ReadAddress = item.ReadAddress || 0, ReadLength: item.ReadLength || 0, Registers: {} });
		var register = {};
		(setdevice = function (subdevice) {
			var item = subdevice.item, subdevices = [];
			item.children.sort(function (a, b) { return a.idx > b.idx ? 1 : a.idx < b.idx ? -1 : 0; });
			register.BitStart = 16 * (register.ReadLength || 0);
			item.children.forEach(function (child, i, children) {
				child.SignalType = child.SignalType || 'UInt';
				var ReadAddress = child.ReadAddress || child.ReadAddress || 0;
				register = device.Registers[ReadAddress] = device.Registers[ReadAddress] || { device: device, ReadAddress: ReadAddress, ReadLength: device.ReadLength = device.ReadLength || 0, children: [], BitStart: 0, BitPos: 0 };
				if (child.class == "Device") { child.ReadAddress = ReadAddress; subdevices.push({ item: child }); }
				else if (child.class == "ControlIO") {
					var control = { id: child.id, title: child.title, SignalType: child.SignalType, Deadband: child.Deadband || 0, Permission: child.Permission, BitPos: register.BitPos = Number(register.BitStart) + Number(child.ReadAddressBit || 0), BitLength: types[child.SignalType].BitLength };
					register.ReadLength = Math.ceil((Number(register.BitPos) + Number(control.BitLength)) / 16);
					register.children.push(control);
				}
			});
			subdevices.forEach(setdevice);
		})(device);

		/*
		console.log('Device', 'IPAddress', item.IPAddress);
		Object.values(device.Registers).forEach(function (register) {
			console.log('  Register', 'ReadAddress', register.ReadAddress, 'ReadLength', register.ReadLength);
			register.children.forEach(function (control) {
				console.log('    Control', JSON.stringify(control));
			});
		});
		*/
		testID = 0;//3563448;
		socket.on('connect', function (event) {
			var device = this, item = device.item;
			if (item.id == testID) console.log('socket=connect');
			//clearTimeout(device.toRead);
			setState(item, 'connect');
			devices.connect();
			(device.readdata = function () {
				var device = this, item = device.item;
				clearTimeout(device.toRead);
				device.toRead = setTimeout(device.readdata, device.readCount ? aim.config.timeWaitAfterTimeout : item.PollInterval);
				if (device.readCount) return setState(item, 'error_read');
				for (var ReadAddress in device.Registers) {
					device.readCount++;
					register = device.Registers[ReadAddress];
					if (item.id == testID) console.log('readInputRegisters-start', register.ReadAddress);
					device.client.readInputRegisters(register.ReadAddress, register.ReadLength).then(function (resp) {
						var register = this, device = register.device, item = device.item;
						if (item.id == testID) console.log('readInputRegisters-then', item.title, device.readCount);
						if (item.State != 'connect') setState(item, 'connect');
						device.readCount--;
						for (var bitArray = [], byteArray = resp.response._body._valuesAsArray, i = byteArray.length - 1 ; i >= 0; i--) bitArray.push(('0000000000000000' + byteArray[i].toString(2)).substr(-16));//value = (value * 65536) + byteArray[i];
						var bitString = bitArray.join('');//value.toString(2);
						register.children.forEach(function (control, i) {
							var item = items[control.id], ReadValue = bitTo(control.SignalType, control.bitString = bitString.substr(bitString.length - control.BitLength - control.BitPos, control.BitLength)), OffsetValue = Math.abs(ReadValue - (item.Value || 0));
							if (item.Value === null || item.Value === undefined || OffsetValue > control.Deadband) setAttribute(item, 'Value', ReadValue);
						});
					}.bind(register)).catch(function (resp) {
						var register = this, device = register.device, item = device.item;
						if (item.id == testID) console.log('readInputRegisters-catch', item.title, device.readCount);
						device.readCount--;
						if (item.State != 'error') setState(item, 'error_read');
					}.bind(register));
				}
			}.bind(device))();
		}.bind(device)).on('disconnect', function (event) {
			var device = this, item = device.item;
			if (item.id == testID) console.log(item.title, 'disconnect');
			setState(item, 'disconnect');
		}.bind(device)).on('error', function (event) {
			var device = this.device, item = device.item;

			if (item.id == testID) console.log(item.title, 'error');
			setState(item, 'error');
			clearTimeout(device.toRead);
			device.toRead = setTimeout(device.connect.bind(device), aim.config.timeWaitAfterTimeout);
			devices.connect();
		});
		device.connect = function () {
			var device = this, item = this.item;
			if (item.id == testID) console.log(item.title, 'device do connect');
			setState(item, 'connecting');
			device.readCount = 0;
			device.socket.connect({ host: item.IPAddress, port: item.Port || 502 });
		}
	});
	devices.connect();
	const snmp = require('snmp-native');
	snmpDevices.forEach(function (item, i) {
		aimdb.log('snmpDevices', item.id);
		var device = { item: item };
		device.session = new snmp.Session({ host: item.IPAddress, community: item.Community });
		device.get = [];
		device.get.oids = [];
		item.children.forEach(function (child) {
			child.device = device;
			device.get.push(child);
			device.get.oids.push(strToOid(child.OID));
		});
		(device.LoadSNMP = function () {
			var device = this, item = device.item;
			device.toRead = setTimeout(device.LoadSNMP, item.PollInterval);
			setTimeout(function () {
				var device = this, item = device.item;
				if (device.reading) {
					if (item.State != 'error_read') setState(item, 'error_read');
					clearTimeout(device.toRead);
					device.toRead = setTimeout(device.LoadSNMP, aim.config.timeWaitAfterTimeout);
				}
			}.bind(device), 1000);
			device.reading = true;
			if (device.get.length) {
				device.get.oids.forEach(function (oid, i) {
					device.session.get({ oid: oid }, function (err, varbinds) {
						var child = this.child, device = this.device, item = device.item;//, setItems = [];
						if (err) {
							if (device.State != 'error_read') setState(item, 'error_read');
						}
						else {
							device.reading = false;
							if (item.State != 'connect') setState(item, 'connect');
							vb = varbinds[0];
							if (child.Value != vb.value) setAttribute(child, 'Value', vb.value);
						}
					}.bind({ child: device.get[i], device: device }));
				});
			}
		}.bind(device))();
	});
}





aimdb = {
	querylist: [],
	exec: function () {
		if (!aim.secret.dbs) return;
		aim.dbs.request(this.querylist.join(';'));
		this.querylist = [];
	},
	post: function (sql) {
		this.querylist.push(sql);
		clearTimeout(this.querylist.to);
		this.querylist.to = setTimeout(this.exec.bind(this), 0);
	},
	log: function (level) {
		var arg = Array.prototype.slice.call(arguments);
		if (!aim.config.loglevel || Number(aim.config.loglevel) <= Number(level)) return;
		if (Number(level)) arg.shift();
		var method = arg.shift()||'';
		var id = Number(arg[0]) ? arg.shift() : null;
		var path = !id ? "" : function () {
			var item = items[id];
			for (var path = [], master = item; master; master = items[master.masterID]) {
				path.push(master.title);
				if (master.class == 'dms_Location') break;
			}
			return path.reverse().join(".");
		}();
		aimdb.post("INSERT aimhis.om.event(method,value,id,path)VALUES('" + method + "','" + JSON.stringify(arg) + "'," + (id || 'NULL') + ",'" + path + "')");
		console.log(new Date().toISOString().replace("T", " ").replace("Z", ""), path, id, method, String(JSON.stringify(arg)).replace(/":/g, '=').replace(/"|{|}/g, ""));
	}
};


const attributeChange = function (item) {
	if (!(item = items[item.id])) return;
	if (item.detailID) item = items[item.detailID];
	if (!item || item.selected == 0) return;
	if (item.schema != 'Attribute' && item.schema != 'ControlIO') return;
	var inputvalue = this.Value, newvalue = Number(inputvalue || 0);
	item.Quality = "Valid";
	if (item.Value && item.Min && item.Max && (item.Min > item.Value || item.Max < item.Value)) item.Quality = "NotValid";
	if (item.Quality != "Valid") {
		aimdb.log("AFKEUR EXIT", item.id, { Quality: item.Quality, value: item.Value, inputvalue: inputvalue });
		return;
	}
	//if (item.id == 3563430) console.log('onchange', item.title, item.Value);
	//if (item.id == 3664213) console.log('onchange', item.title, item.Value);
	//console.log('CALC',item.Calc, inputvalue);

	if (inputvalue != undefined) {
		if (this.MaxEngValue != null && this.MinEngValue != null && this.MaxRawValue != null && this.MinRawValue != null) newvalue = Math.round(((Number(this.MaxEngValue) - Number(this.MinEngValue)) / (Number(this.MaxRawValue) - Number(this.MinRawValue)) * (newvalue - Number(this.MinRawValue)) + Number(this.MinEngValue)) * 100) / 100;
		if (item.Low != null && item.High != null && item.High <= item.Low) { newvalue = newvalue >= Number(item.High) && newvalue <= Number(item.Low) ? 1 : ((newvalue <= Number(item.High) - (Number(item.Hysteresis || 0))) || (newvalue >= Number(item.Low) + Number(item.Hysteresis || 0)) ? 0 : Number(item.Value)); }
		else if (item.Low != null) { newvalue = newvalue <= Number(item.Low) ? 1 : (newvalue >= Number(item.Low) + Number(item.Hysteresis || 0) ? 0 : Number(item.Value)); }
		else if (item.High != null) { newvalue = newvalue >= Number(item.High) ? 1 : (newvalue <= Number(item.High) - Number(item.Hysteresis || 0) ? 0 : Number(item.Value)); }
		//console.log(item.Calc);
		if (item.Calc == 'OnlineHours') {
			//console.log('OnlineHours event',item.title, item.Value);
			item.deltaTimeS = 3600;
			(item.OnlineHours = function () {
				clearTimeout(timers[this.id]);

				var master = items[this.masterID], masterOn = Number(master.Value);
				//masterOn = 1; // MKA
				//console.log('OnlineHours', masterOn, this.masterStart);
				if (this.masterStart) setAttribute(this, 'Value', Number(this.Value || 0) + ((new Date().valueOf() - this.masterStart.valueOf()) / 1000 / 3600), true);
				this.masterStart = masterOn ? new Date() : null;
				if (masterOn) timers[this.id] = setTimeout(this.OnlineHours.bind(this), this.deltaTimeS * 1000);
			}).call(item);
		}
		else setAttribute(item, 'Value', newvalue);
	}
	else if (item.children) item.children.forEach(attributeChange.bind(item));
}


//aim = new EventEmitter();



var a = {
	items: items,
	setAttribute: setAttribute,
	setState: setState,
	setTest: function (val) {
		test = val;
		console.log(test, val);
	},
	log: aimdb.log,
	load: function (par) {
		if (par.input) {
			par.input = JSON.stringify(par.input);
			par.options.headers = {
				'Content-Type': 'application/json',
				'Content-Length': par.input.length
			};
		}
		const req = require(par.protocol).request(par.options, (res) => {
			//console.log(`statusCode: ${res.statusCode}`);
			res.on('data', (d) => {
				d = String(d);
				try {
					res.data = d[0] == '{' ? JSON.parse(d) : d;
				}
				catch (err) {
					console.log('error json', d);
				}
				//console.log('d:consolelog',String(d));
				//process.stdout.write('d:'+d)
			});
			res.on('end', par.onload);
		});
		req.on('error', (error) => {
			console.error(error)
		});
		req.write(par.input);
		req.end();
	},

	assign : function(device) {
		for (var name in device) module[name] = device[name];
	},
	assignModule : function (name,definition) {
		module[name] = function (schema,id) {
			//console.log('Request for module',schema,id,this);
			return module[schema][id];
		}.bind(this,name);
		module[name].definition = definition;
	},
	appendModule: function (item) {
		module[item.schema][item.id] = new module[item.schema].definition(item.id);
	},
}


//var signature = crypto.createHmac('sha256', "87636bdb-80a4-422b-9fdd-72b4386c7b2f").update("BfB9UL4JFolS2OyFToAaUw==").digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');

//console.log(signature);
